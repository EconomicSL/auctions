/** Create a new `MatchedOrders` instance with the given matched pair of `(AskOrder, BidOrder)` removed.
    *
    * @param reference
    * @return a new `MatchedOrders` instance that contains all of the `AskOrder` and `BidOrder` instances of this
    *         instance but that does not contain the matched pair of  `orders`.
    */
  def - (reference: Reference): (MatchedOrders[T], Option[((Token, Order[T]), (Reference, (Token, Order[T])))]) = {
    val (remainingAskOrders, removedAskOrder) = askOrders - reference
    removedAskOrder match {
      case Some(askOrder) =>
        val (remainingBidOrders, Some(marginalBidOrder)) = bidOrders.splitOffTopOrder
        (new MatchedOrders(remainingAskOrders, remainingBidOrders), Some((askOrder, marginalBidOrder)))
      case None =>
        val (remainingBidOrders, removedBidOrder) = bidOrders - reference
        removedBidOrder match {
          case Some(bidOrder) =>
            val (remainingAskOrders, Some(marginalAskOrder)) = askOrders.splitOffTopOrder
            (new MatchedOrders(remainingAskOrders, remainingBidOrders), Some((bidOrder, marginalAskOrder)))
          case None =>
            (this, None)
        }
    }
  }


    def insert(kv: (Reference, (Token, Order[T]))): FourHeapOrderBook[T] = kv match {
      case (reference, (token, order: AskOrder[T])) =>
        (matchedOrders.headOption, unMatchedOrders.bidOrders.headOption) match {
          case (Some(((_, (_, matchedAskOrder)), _)), Some((existing, rationedBidOrder @ (_, bidOrder))))
            if order.limit <= bidOrder.limit && matchedAskOrder.limit <= bidOrder.limit =>
            val (remainingUnMatchedOrders, _) = unMatchedOrders - existing
            val updatedMatchedOrders = matchedOrders + (reference -> (token -> order), existing -> rationedBidOrder)
            new FourHeapOrderBook(updatedMatchedOrders, remainingUnMatchedOrders)
          case (None, Some((existing, unMatchedBidOrder @ (_, bidOrder)))) if order.limit < bidOrder.limit =>
            val (remainingUnMatchedOrders, _) = unMatchedOrders - existing
            val updatedMatchedOrders = matchedOrders + (reference -> (token -> order), existing -> unMatchedBidOrder)
            new FourHeapOrderBook(updatedMatchedOrders,remainingUnMatchedOrders)
          case (Some(((existing, (_, matchedAskOrder)), _)),  _) if order.limit < matchedAskOrder.limit =>
            val (updatedMatchedOrders, matchedAskOrder) = matchedOrders.replace(existing, reference -> (token -> order))
            new FourHeapOrderBook(updatedMatchedOrders, unMatchedOrders + (existing -> matchedAskOrder))
          case _ =>
            new FourHeapOrderBook(matchedOrders, unMatchedOrders + (reference -> (token -> order)))
        }
      case (reference, (token, order: BidOrder[T])) =>
        (matchedOrders.headOption, unMatchedOrders.askOrders.headOption) match {
          case (Some((_, (_, (_, matchedBidOrder)))), Some((existing, rationedAskOrder @ (_, askOrder))))
            if order.limit >= askOrder.limit && matchedBidOrder.limit >= askOrder.limit =>
            val (remainingUnMatchedOrders, _) = unMatchedOrders - existing
            val updatedMatchedOrders = matchedOrders + (existing -> rationedAskOrder, reference -> (token -> order))
            new FourHeapOrderBook(updatedMatchedOrders, remainingUnMatchedOrders)
          case (None, Some((existing, unMatchedAskOrder @ (_, askOrder)))) if order.limit > askOrder.limit =>
            val (remainingUnMatchedOrders, _) = unMatchedOrders - existing
            val updatedMatchedOrders = matchedOrders + (existing -> unMatchedAskOrder, reference -> (token -> order))
            new FourHeapOrderBook(updatedMatchedOrders, remainingUnMatchedOrders)
          case (Some(((existing, (_, bidOrder)), _)), _) if order.limit > bidOrder.limit => // no rationing!
            val (updatedMatchedOrders, matchedBidOrder) = matchedOrders.replace(existing, reference -> (token -> order))
            new FourHeapOrderBook(updatedMatchedOrders, unMatchedOrders + (existing -> matchedBidOrder))
          case _ =>
            new FourHeapOrderBook(matchedOrders, unMatchedOrders + (reference -> (token -> order)))
        }
    }